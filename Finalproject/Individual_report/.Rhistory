## ========================
## Preparation
## ========================
## load necessary packages
library(qgraph)
library(pcalg)
library(dplyr)
## source all the necessary functions
source("code/R/CCD_fnc.R")
source("code/R/plot_fnc.R")
source("code/R/dsep_fnc.R")
source("code/R/searchAM_KP_fnc.R")
source("code/R/equivset_fnc.R")
source("code/R/data_generating_fnc.R")
source("code/R/eval_metric_fnc.R")
## ========================
## Model 1) 4 nodes - sparse
## ========================
# specify B matrix
p = 4
B4 = matrix(c(0, 0, 0, 0,
1, 0, 0.5, 0,
0, 0.5, 0, 0.9,
0, 0, 0, 0), p, p, byrow = T)
colnames(B4) <- c("X1", "X2", "X3", "X4")
# specify layout
layout4 = matrix(c(-1,1,
-1,0,
1,0,
1,1),4,2,byrow = T)
# ## True graph
# true4p <- qgraph(t(B4), layout=layout4, labels = colnames(B4), theme="colorblind")
#
#
# ## Data generating
# # equilibrium check
# equilibrium_check(B4)
# # generate data
# data4p <- gen_dat(B4, N =1e6, seed = 1)
#
# ## GGM
# ggm4p <- qgraph(cor(data4p), layout=layout4, theme="colorblind")
#
# ## run CCD algorithm
# ccd_4p <- ccdKP(df=data4p, dataType = "continuous", alpha = 0.05)
## Estimate PAG
# pag4p <- plotPAG(ccd_4p, mat4p)
## Compute equivalence class of all DCGs given the PAG
# (this takes relatively a long time, so we save the object)
# equiv4p <- semiequiv_dcg(ccd_4p, mat4p)
# save(equiv4p, file="data/equiv4p.RData")
# load("data/equiv4p.RData")
## ========================
## Model 2) 4 nodes - dense
## ========================
# specify B matrix
p = 4
B4_high = matrix(c(0, 0, 0, 0,
0.9, 0, 0.4, 0,
0, 0.5, 0, .5,
-0.8, 0, 0, 0), p, p, byrow = T)
colnames(B4_high) <- c("X1", "X2", "X3", "X4")
# ## True graph
# true4p_high <- qgraph(t(B4_high), layout=layout4, labels = colnames(B4_high), theme="colorblind")
#
# ## Data generating
# # equilibrium check
# equilibrium_check(B4_high)
# # generate data
# data4p_high <- gen_dat(B4_high, N =1e6, seed = 1)
#
# ## GGM
# ggm4p_high <- qgraph(t(cor(data4p_high)), layout=layout4, theme="colorblind")
#
# ## run CCD algorithm
# ccd_4p_high <- ccdKP(df=data4p_high, dataType = "continuous", alpha = 0.05)
# mat4p_high <- CreateAdjMat(ccd_4p_high, 4)
# Estimate PAG
# pag4p <- plotPAG(ccd_4p_high, mat4p_high)
## Compute equivalence class of all DCGs given the PAG
# (this takes relatively a long time, so we save the object)
# equiv4p_high <- semiequiv_dcg(ccd_4p_high, mat4p_high)
# save(equiv4p_high, file="data/equiv4p_high.RData")
# load("data/equiv4p_high.RData")
## ========================
## Model 3) 5 nodes - sparse
## ========================
# specify B matrix
p = 5
B5 = matrix(c(0, 1, 0, 0, 0,
0, 0, 0, 0.7, 0,
0, 0.4, 0, 0, 0,
0, 0, .5, 0, 0,
0, 0, 0, -1.5, 0), p, p, byrow = T)
colnames(B5) <- c("X1", "X2", "X3", "X4", "X5")
# specify layout
layout5 = matrix(c(0,1,
0,0,
1,-1,
2,0,
2,1),5,2,byrow = T)
# ## True graph
# true5p <- qgraph(t(B5), layout=layout5, labels = colnames(B5), theme="colorblind")
#
# ## Data generating
# # equilibrium check
# equilibrium_check(B5)
# # generate data
# data5p <- gen_dat(B5, N =1e6, seed = 123)
#
# ## GGM
# ggm5p <- qgraph(cor(data5p), layout = layout5, theme="colorblind")
#
# ## run CCD algorithm
# ccd_5p <- ccdKP(df=data5p, dataType = "continuous", alpha = 0.05)
# mat5p <- CreateAdjMat(ccd_5p, 5)
# Estimate PAG
# pag5p <- plotPAG(ccd_5p, mat5p)
## Compute equivalence class of all DCGs given the PAG
# (this takes relatively a long time, so we save the object)
# equiv5p <- semiequiv_dcg(ccd_5p, mat5p)
# save(equiv5p, file="data/equiv5p.RData")
# load("data/equiv5p.RData")
## ========================
## Model 4) 5 nodes - dense
## ========================
# specify B matrix
p = 5
B5_high = matrix(c(0, 0.9, 0, 0, 0.6,
0, 0, 0, 0.7, 0,
0, 0.9, 0, 0, 0,
0, 0, 0.5, 0, 0,
0, 0, 0, 1, 0), p, p, byrow = T)
colnames(B5_high) <- c("X1", "X2", "X3", "X4", "X5")
# specify layout
layout5 = matrix(c(0,1,
0,0,
1,-1,
2,0,
2,1),5,2,byrow = T)
# ## True graph
# true5p_high <- qgraph(t(B5_high), layout=layout5, labels = colnames(B5_high), theme="colorblind")
#
# ## Data generating
# # equilibrium check
# equilibrium_check(B5_high)
# # generate data
# data5p_high <- gen_dat(B5_high, N =1e6, seed = 1)
#
# ## GGM
# ggm5p_high <- qgraph(cor(data5p_high), layout = layout5, theme="colorblind")
#
# ## run CCD algorithm
# ccd_5p_high <- ccdKP(df=data5p_high, dataType = "continuous", alpha = 0.05)
# mat5p_high <- CreateAdjMat(ccd_5p_high, 5)
## Estimate PAG
# pag5p_high <- plotPAG(ccd_5p_high, mat5p_high)
## Compute equivalence class of all DCGs given the PAG
# (this takes relatively a long time, so we save the object)
# equiv5p_high <- semiequiv_dcg(ccd_5p_high, mat5p_high)
# save(equiv5p_high, file="data/equiv5p_high.RData")
# load("data/equiv5p_high.RData")
## ========================
## Model 5) 6 nodes - sparse
## ========================
# specify B matrix
p = 6
B6 = matrix(c(0, 0, 0, 0, 0, 0,
0.3, 0, 0.4, 0, 0, 0,
0, 0, 0, 0.9, 0, 0,
0, 0, 0, 0, 0.4, 0,
0, 0, 1, 0, 0, 0,
1, 0, 0, 0, 0.5, 0), p, p, byrow = T)
colnames(B6) <- c("X1", "X2", "X3", "X4", "X5", "X6")
# specify layout
layout6 = matrix(c(1, 2,
0,1,
0,0,
1,-1,
2,0,
2,1),6,2,byrow = T)
# ## True graph
# true6p <- qgraph(t(B6), layout=layout6, labels = colnames(B6), theme="colorblind")
#
# ## Data generating
# # equilibrium check
# equilibrium_check(B6)
# # generate data
# data6p <- gen_dat(B6, N =1e6, seed = 123)
#
# ## GGM
# ggm6p <- qgraph(cor(data6p), layout = layout6, theme="colorblind")
#
#
# ## run CCD algorithm
# ccd_6p <- ccdKP(df=data6p, dataType = "continuous", alpha = 0.05)
# mat6p <- CreateAdjMat(ccd_6p, 6)
## Estimate PAG
# pag6p <- plotPAG(ccd_6p, mat6p)
## Compute equivalence class of all DCGs given the PAG
# (this takes relatively a long time, so we save the object)
# equiv6p <- semiequiv_dcg(ccd_6p, mat6p)
# save(equiv6p, file="data/equiv6p.RData")
# load("data/equiv6p.RData")
## ========================
## Model 6) 6 nodes - dense
## ========================
# specify B matrix
p = 6
B6_high = matrix(c(0, 0, 0, 0, 0, 0,
0.7, 0, 0.4, 0, 0, 0.9,
0, 0, 0, 0.9, 0, 0,
0, 0, 0, 0, 0.4, 0,
0, 0, 1, 0, 0, 0,
1, 0, 0, 0, 0.5, 0), p, p, byrow = T)
# colnames for B matrix is necessary for running CCD
colnames(B6_high) <- c("X1", "X2", "X3", "X4", "X5", "X6")
# true6p_high <- qgraph(t(B6_high), layout=layout6, labels = colnames(B6), theme="colorblind")
#
# ## Data generating
# # equilibrium check
# equilibrium_check(B6_high)
# # generate data
# data6p_high<- gen_dat(B6_high, N =1e6, seed = 123)
#
# ## GGM
# ggm6p_high <- qgraph(cor(data6p_high), layout = layout6, theme="colorblind")
#
# ## run CCD algorithm
# ccd_6p_high <- ccdKP(df=data6p_high, dataType = "continuous", alpha = 0.05)
# mat6p_high <- CreateAdjMat(ccd_6p_high, 6)
## Estimate PAG
# pag6p_high <- plotPAG(ccd_6p_high, mat6p_high)
## Compute equivalence class of all DCGs given the PAG
# (this takes relatively a long time, so we save the object)
# equiv6p_high <- semiequiv_dcg(ccd_6p_high, mat6p_high)
# save(equiv6p_high, file="data/equiv6p_high.RData")
# load("data/equiv6p_high.RData")
## source all the necessary functions
source("code/R/CCD_fnc.R")
source("code/R/plot_fnc.R")
source("code/R/dsep_fnc.R")
source("code/R/searchAM_KP_fnc.R")
rm(list=ls())
## =============================================================================
#
## Preparation
#
## =============================================================================
## source all the functions
source("code/R/variation_fnc.R")
source("code/simulation.R")
## load all the equivalence set of DCGs from the simulation
load("data/equiv4p.RData")
load("data/equiv4p_high.RData")
load("data/equiv5p.RData")
load("data/equiv5p_high.RData")
load("data/equiv6p.RData")
load("data/equiv6p_high.RData")
## 1) compute the density for DCGs per model
# 4 node-sparse
denvar4p <-DCGdensities(equiv4p)
# 4 node-dense
denvar4phigh <-DCGdensities(equiv4p_high)
# 5 node-sparse
denvar5p <-DCGdensities(equiv5p)
# 5 node-dense
denvar5phigh <-DCGdensities(equiv5p_high)
# 6 node-sparse
denvar6p <-DCGdensities(equiv6p)
# 6 node-dense
denvar6phigh <-DCGdensities(equiv6p_high)
# put them all together in a list
modeldensities <- list(denvar4p, denvar4phigh, denvar5p, denvar5phigh, denvar6p, denvar6phigh)
names(modeldensities) <- c("(a) 4 nodes - sparse", "(b) 4 nodes - dense", "(c) 5 nodes - sparse", "(d) 5 nodes - dense", "(e) 6 nodes - sparse", "(f) 6 nodes - dense")
## 2) compute the true model densities
truemodels <- list(B4, B4_high, B5, B5_high, B6, B6_high) %>%
purrr::map(~truemoddensity(.)) %>% unlist()
## 3) plot the distributions of density per model
# specify bin numbers
bins <- c(15, 15, 15, 15, 20, 20)
# storage for plots
plotlist1 <- list()
for(i in 1:length(modeldensities)){
# get the size of equivalence class
N <- modeldensities[[i]]$class_size[1]
plotlist1[[i]] <- as.data.frame(modeldensities[[i]]) %>%
mutate(trueden = truemodels[i]) %>%
# plot density distribution using histogram
ggplot(aes(x=densities)) +
geom_histogram(color="gray", fill="lightblue", bins = bins[i]) +
xlim(0.25, 1.01) +
# add a line indicating average density of DCGs
geom_vline(aes(xintercept = avg_density, color = "average density of DCGs"),
lwd = 0.3, linetype=2) +
# add a line indicating true density
geom_vline(aes(xintercept = trueden, color = "density of true model"),
lwd = 0.3, linetype=2) +
# add extra aesthetics for the plot
theme_classic() + labs(title = names(modeldensities)[i],
subtitle = paste("Size of equivalence class = ", N),
x = "density") +
scale_color_manual(name = "", values = c("density of true model" = "red",
"average density of DCGs" = "darkblue"))+
theme(plot.title = element_text(size = 10, face="bold"),
plot.subtitle=element_text(size=10, face="italic"))
}
# load necessary packages
library(qgraph)
library(pcalg)
library(dplyr)
library(ggplot2)
## source all the functions
source("code/R/variation_fnc.R")
source("code/simulation.R")
## load all the equivalence set of DCGs from the simulation
load("data/equiv4p.RData")
load("data/equiv4p_high.RData")
load("data/equiv5p.RData")
load("data/equiv5p_high.RData")
load("data/equiv6p.RData")
load("data/equiv6p_high.RData")
## =============================================================================
## Examine overall density variation (Figure 2)
#
# 1. Compute the density for DCGs.
# 2. Compute the density for true models.
# 3. Plot the distribution of densities of DCGs
#    and add a line for true density as well as for average DCG density.
## =============================================================================
## 1) compute the density for DCGs per model
# 4 node-sparse
denvar4p <-DCGdensities(equiv4p)
# 4 node-dense
denvar4phigh <-DCGdensities(equiv4p_high)
# 5 node-sparse
denvar5p <-DCGdensities(equiv5p)
# 5 node-dense
denvar5phigh <-DCGdensities(equiv5p_high)
# 6 node-sparse
denvar6p <-DCGdensities(equiv6p)
# 6 node-dense
denvar6phigh <-DCGdensities(equiv6p_high)
# put them all together in a list
modeldensities <- list(denvar4p, denvar4phigh, denvar5p, denvar5phigh, denvar6p, denvar6phigh)
names(modeldensities) <- c("(a) 4 nodes - sparse", "(b) 4 nodes - dense", "(c) 5 nodes - sparse", "(d) 5 nodes - dense", "(e) 6 nodes - sparse", "(f) 6 nodes - dense")
## 2) compute the true model densities
truemodels <- list(B4, B4_high, B5, B5_high, B6, B6_high) %>%
purrr::map(~truemoddensity(.)) %>% unlist()
## 3) plot the distributions of density per model
# specify bin numbers
bins <- c(15, 15, 15, 15, 20, 20)
# storage for plots
plotlist1 <- list()
for(i in 1:length(modeldensities)){
# get the size of equivalence class
N <- modeldensities[[i]]$class_size[1]
plotlist1[[i]] <- as.data.frame(modeldensities[[i]]) %>%
mutate(trueden = truemodels[i]) %>%
# plot density distribution using histogram
ggplot(aes(x=densities)) +
geom_histogram(color="gray", fill="lightblue", bins = bins[i]) +
xlim(0.25, 1.01) +
# add a line indicating average density of DCGs
geom_vline(aes(xintercept = avg_density, color = "average density of DCGs"),
lwd = 0.3, linetype=2) +
# add a line indicating true density
geom_vline(aes(xintercept = trueden, color = "density of true model"),
lwd = 0.3, linetype=2) +
# add extra aesthetics for the plot
theme_classic() + labs(title = names(modeldensities)[i],
subtitle = paste("Size of equivalence class = ", N),
x = "density") +
scale_color_manual(name = "", values = c("density of true model" = "red",
"average density of DCGs" = "darkblue"))+
theme(plot.title = element_text(size = 10, face="bold"),
plot.subtitle=element_text(size=10, face="italic"))
}
# put all plots together (results in Figure2)
ggpubr::ggarrange(plotlist=plotlist1, nrow=3, ncol=2, common.legend = T, legend = "bottom")
## =============================================================================
## Examine degree centrality variation (Figure 3)
#
# 1. Compute the degree for all nodes in DCGs.
# 2. Compute the standard errors (SE) per model.
# 3. Plot the average degree centrality with the 95% confidence interval.
## =============================================================================
## 1) obtain degrees per node
## 2) and compute the SE  for all DCGs
# 4 node-sparse
degvar4p <- DCGdegrees(equiv4p) %>%
# compute SE
mutate(se = deg_sd * qnorm(0.975) / length(equiv4p), name = "(a) 4 nodes - sparse")
# 4 node-dense
degvar4phigh <- DCGdegrees(equiv4p_high) %>%
mutate(se = deg_sd * qnorm(0.975) / length(equiv4p_high), name = "(b) 4 nodes - dense")
# 5 node-sparse
degvar5p <- DCGdegrees(equiv5p) %>%
mutate(se = deg_sd * qnorm(0.975) / length(equiv5p), name = "(c) 5 nodes - sparse")
# 5 node-dense
degvar5phigh <- DCGdegrees(equiv5p_high) %>%
mutate(se = deg_sd * qnorm(0.975) / length(equiv5p_high), name = "(d) 5 nodes - dense")
# 6 node-sparse
degvar6p <- DCGdegrees(equiv6p) %>%
mutate(se = deg_sd * qnorm(0.975) / length(equiv6p), name = "(e) 6 nodes - sparse")
# 6 node-dense
degvar6phigh <- DCGdegrees(equiv6p_high) %>%
mutate(se = deg_sd * qnorm(0.975) / length(equiv6p_high), name = "(f) 6 nodes - dense")
# put all degrees per model together in a list
modeldegrees <- list(degvar4p, degvar4phigh, degvar5p, degvar5phigh, degvar6p, degvar6phigh)
## 3) create the degree centrality plots for each model with 95% confidence interval
# storage for plots
plotlist2 <- modeldegrees %>%
purrr::map(~
ggplot(data =., aes(x=node, y=avg_degree)) +
# we multiply SEs by 100 to scale up (hard to visualize them otherwise)
# add the errorbars (95% CIs)
geom_errorbar(aes(ymin=avg_degree-se*100, ymax=avg_degree+se*100), width=0.1,
color = "darkblue") +
geom_line(group=1, color = "darkblue") + geom_point(size=0.7) +
# add extra aesthetics for the plot
theme_minimal() + ylim(0, 5) +
labs(title = .$name,  y = "average degree") +
theme(plot.title = element_text(size = 10, face="bold"))
)
# put all plots together (results in Figure3)
ggpubr::ggarrange(plotlist=plotlist2, nrow=3, ncol=2, common.legend = T, legend = "bottom")
rm(list=ls())
## source necessary functions
source("code/R/CCD_fnc.R")
source("code/R/plot_fnc.R")
## import example empirical data
mcnally <- read.csv("data/McNally.csv")
library(qgraph)
library(pcalg)
library(ggplot2)
library(dplyr)
## source necessary functions
source("code/R/CCD_fnc.R")
source("code/R/plot_fnc.R")
## import example empirical data
mcnally <- read.csv("data/McNally.csv")
# separate depression / OCD symptoms
# (original data contains both depression and OCD symptoms)
# (here we only use depression symptoms)
depression <- mcnally[,1:16]
ocd <- mcnally[,17:26]
## =======================================
## 2. Estimate GGM with GLASSO (Figure 5)
## =======================================
## estimate GGM via graphical LASSO on depression symptoms
cordep <- cor(depression)
# found the optimal sparsity by gamma = 1
glassoFitdep <- EBICglasso(cordep, n = nrow(depression), gamma = 1)
qgraph(glassoFitdep, layout = "spring", theme="colorblind",
nodeNames = colnames(depression), legend.cex = 0.4)
## =======================================
## 3. Estimate PAG using CCD (Figure 4)
## =======================================
## estimate the PAG on depression symptoms by running CCD
# run CCD
ccd_mcnally_dep <- ccdKP(df=depression, dataType = "discrete", depth = -1)
# create an adjacency matrix for PAG
mat_mcnally_dep <- CreateAdjMat(ccd_mcnally_dep, p = ncol(depression))
# plot the PAG
pag_mcnally_dep <- plotPAG(ccd_mcnally_dep, mat_mcnally_dep)
